// build.rs: keeps static files to be served inside the main executable, allowing for blasting-fast service (without context switches)

use std::{
    env,
    fs,
    path::{Path,PathBuf},
    io::{Write,BufWriter},
    process::Command,
    collections::HashMap,
};
use flate2::{
    GzBuilder,
    Compression,
    write::GzEncoder,
};

/// how smaller (in bytes) the gzipped file must be, in comparison to the plain version, for us to serve it in the compressed form
const GZIP_THRESHOLD: usize = 100;

fn main() {

    eprintln!("Running custom build.rs:");

    #[cfg(debug_assertions)]
    on_non_release();

    #[cfg(not(debug_assertions))]
    on_release();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=angular/src");
}

fn on_non_release() {
    eprintln!("\t(nothing to run, since we're not compiling for Release)");
    save_static_files(
        HashMap::from([
            ("/index.html".to_string(), Vec::from("RUNNING IN NON-RELEASE MODE (redirects to localhost:4200/)".as_bytes())),
        ]),
        HashMap::from([
            ("/".to_string(), "/index.html".to_string())
        ])
    );
}

/// builds the angular site for production, then loads (and compresses) the resulting static files, storing them in a hash map for use by the application
fn on_release() {
    let angular_relative_path = "./angular";
    let angular_dist_path = format!("{}/dist/DemoAngularAndBootstrapUI", angular_relative_path);
    let angular_production_build_command = format!("cd '{}' && ng build --aot --build-optimizer --optimization --prod --progress", angular_relative_path);
    let get_angular_routes_command = format!(r#"grep "{{ path: '" {}/src/app/app-routing.module.ts | sed "s|.* path: '\([^']*\)'.*|\1|""#, angular_relative_path);

    eprintln!("\tRunning Angular's production build: '{}'", angular_production_build_command);
    let shell;
    if cfg!(target_os = "windows") {
        shell = "cmd";
    } else {
        shell = "sh";
    };
    let _exit_status = Command::new(shell)
        .args(["-c", &angular_production_build_command])
        .spawn().expect("Failed to start Angular UI Application!")
        .wait().unwrap();

    let mut files_contents = HashMap::<String, Vec<u8>>::new();
    let mut current_dir = env::current_dir().unwrap();
    current_dir = current_dir.join(angular_dist_path);
    let root_dir = PathBuf::from(&current_dir);
    eprintln!("Incorporating all files from '{:?}' into the executable", root_dir);

    // reads all static files
    for entry in fs::read_dir(&current_dir).expect(&format!("Cannot traverse directory '{:?}", &current_dir)) {
        let entry = entry.unwrap();
        let path = entry.path();

        let metadata = fs::metadata(&path).unwrap();

        if metadata.is_file() {
            let file_contents = fs::read(&path).expect(&format!("Cannot read file contents: '{:?}'", path));
            let relative_file_name = path.to_string_lossy().to_string().replace(root_dir.to_str().unwrap(), "");
            files_contents.insert(relative_file_name, file_contents);
        }
    }

    // includes all angular routes as static files (downloading index.html)
    let output = Command::new(shell)
        .args(["-c", &get_angular_routes_command])
        .output().expect("Failed to start Angular UI Application!")
        .stdout;
    let output_string = String::from_utf8(output).expect("command not in UTF-8");
    let routes = output_string.split("\n");
    let file_links: HashMap<String, String> = routes.into_iter()
        .map(|route| (format!("/{}", route), "/index.html".to_string()) )
        .collect();
    //file_links.insert("/".to_string(), "/index.html".to_string());    <-- already included by the above command for an empty line (path: '')

    save_static_files(files_contents, file_links);
}

/// saves (possibly compressing) 'static_files' into a const hash map for use by the application.\
/// 'file_links' := {link_name = real_file_name, ...}
fn save_static_files(static_files: HashMap<String, Vec<u8>>, file_links: HashMap<String, String>) {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("static_files.rs");
    let mut writer = BufWriter::with_capacity(4*1024*1024, fs::File::create(dest_path).unwrap());

    // file names to Rust identifiers (file contents are stored in consts)
    fn file_name_as_token(file_name: &str) -> String {
        let to_understore = ["/", "-", "."];
        let mut file_name_as_token = file_name.to_string();
        file_name_as_token.insert_str(0, "FILE_");
        for replacement in to_understore {
            file_name_as_token = file_name_as_token.replace(replacement, "_");
        }
        file_name_as_token
    }

    let file_header = r#"
// Auto-generated by build.rs. See there for docs.

use std::collections::HashMap;

"#;
    let hash_map_header = r#"

lazy_static! {
    pub static ref STATIC_FILES: HashMap<&'static str, (/*gzipped*/bool, /*contents*/&'static [u8])> = {
        let mut m = HashMap::new();
"#;
    let function_and_file_footers = r#"
        m
    };
}"#;

    // header
    writer.write(file_header.as_bytes()).unwrap();

    // constants
    for (file_name, file_contents) in &static_files {
        let mut gzip = GzEncoder::new(Vec::new(), Compression::best());
        gzip.write_all(file_contents).unwrap();
        let gzipped_bytes = gzip.finish().expect(&format!("Could not compress file '{}'", file_name));
        if gzipped_bytes.len() + GZIP_THRESHOLD < file_contents.len() {
            // serve it gzipped (text)
            writer.write(format!("// \"{}\": {} compressed / {} plain ==> compressed to {:.2}% of the original\n\
                                       const {}: (bool, &[u8]) = (true, &{:?});\n",
                                     file_name, gzipped_bytes.len(), file_contents.len(), (gzipped_bytes.len() as f64 / file_contents.len() as f64) * 100.0,
                                     file_name_as_token(file_name), gzipped_bytes.as_slice()).as_bytes());
        } else {
            // serve it plain (images, videos, ...)
            writer.write(format!("// \"{}\": {} compressed / {} plain ==> would be {:.2}% of the original\n\
                                       const {}: (bool, &[u8]) = (false, &{:?});\n",
                                      file_name, gzipped_bytes.len(), file_contents.len(), (gzipped_bytes.len() as f64 / file_contents.len() as f64) * 100.0,
                                      file_name_as_token(file_name), file_contents.as_slice()).as_bytes());
        }
    }

    // hash map header
    writer.write(hash_map_header.as_bytes()).unwrap();

    // contents (hash map)
    writer.write("        // links\n".as_bytes());
    for (link_name, real_file_name) in &file_links {
        writer.write(format!("        m.insert(\"{}\", {});\n", link_name, file_name_as_token(real_file_name)).as_bytes());
    }
    writer.write("        // files\n".as_bytes());
    for (file_name, file_contents) in &static_files {
        writer.write(format!("        m.insert(\"{}\", {});\n", file_name, file_name_as_token(file_name)).as_bytes());
    }

    // footer
    writer.write(function_and_file_footers.as_bytes()).unwrap();
}
